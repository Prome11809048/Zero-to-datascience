# -*- coding: utf-8 -*-
"""Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K9u2Xk2jIiJk6eX_rgWS3Lv-eAc1rB4t

For printing any text in python we can use single quote and double quote both

# Print function
"""

print("Machine Learning")

print('Machine Learning')

"""Text joining or String concatenation"""

print("Machine Learning" + " Projects")

"""Print Numbers"""

print(8)

print(8+3)

"""#Basic datatypes

Data types

1.   int
2.   float
3.   str (for string)
4.   Complex
6.   Boolean
"""

type(8)

type(8.1)

type("Machine")

c = 1 + 3j
type(c)

c = True
type(c)

c = 7 < 3
type(c)

"""String slicing"""

my_string = "Programming"
print(my_string[1:5])

my_string = "Programming"
print(my_string[0:10:2])

"""# Special Datatype

Multiple Objects

1. List
2. Tuple
3. Set
4. Dictionary
"""

# List should be included in square bracket
my_list = [1,2,3,4,5]
print(my_list)

# List can have multiple values
my_list = [1,2.2,3,"English", True]
my_list_1 = []

#insert an element into list
my_list.append(4)
# print a specific value in list
print(my_list[0])
print(my_list)
# print length of a list
print(len(my_list))

#delete a list
del my_list_1
#print(my_list_1)

#Join two list
my_list_2 = [1,2,3,4,5]
my_list_3 = [6,7,8,9,10]
my_list_4 = my_list_2 + my_list_3
print(my_list_4)

# Tuple should be included in round bracket
my_tuple = (1,2,3,4,5)
print(my_tuple)
type(my_tuple)

# tuples allow multiple data type
my_tuple = (1,2.2,3,"English", True)
print(my_tuple)

# convert tuple to list
my_list = list(my_tuple)
print(my_list)

# convert list to tuple
my_tuple = tuple(my_list)
print(my_tuple)

#print specific data from tuple
print(my_tuple[0])
print(my_tuple[1])
print(my_tuple[2])
print(my_tuple[3])
print(my_tuple[4])

#tuple is immutable or unchangeable
#my_tuple[0] = 100
#print(my_tuple)

# set with curly brackets
my_set = {1,2,3,4,5}
print(my_set)
type(my_set)

# Set does not support indexing
#print(my_set[0])

# Set does not support slicing
#print(my_set[1:3])

#convert list to a set
my_list = [1,2,3,4,5,6,7,8,9,10]
my_set = set(my_list)
print(my_set)

#set doesn't support duplicate value
my_set = {1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10}
print(my_set)

#Dictionary contains key-value pair
my_dict = {'name': 'David', 'age': 30, 'city': 'New York'}
print(my_dict)

# print values through key
print(my_dict['name'])
print(my_dict['age'])
print(my_dict['city'])

# update value
my_dict['age'] = 31
print(my_dict)

# Dictionary doesn't alow duplicate value
my_dict = {'name': 'David', 'age': 30, 'city': 'New York', 'age': 31}
print(my_dict)

"""# Constant and Variables"""

marvel_superhero = "Iron man"
print(marvel_superhero)

marvel_superhero = "Captain America"
print(marvel_superhero)

marvel_superhero = "Iron man"
marvel_superhero = "Captain America"
print(marvel_superhero)

hero1 ,hero2, hero3 = "Iron man" , "Captain America" , "Thor"
print(hero1)
print(hero2)
print(hero3)

"""In Python, constants are typically declared using uppercase variable names by convention, not by enforced language rules. Python does not have built-in constant types like some other languages (e.g., final in Java or const in C++). Instead, developers use naming conventions and discipline to indicate that a variable should not be changed.

# Input from user
"""

number_1 = input("Enter the first number : ")
number_2 = input("Enter the second number : ")

sum = number_1 + number_2
print(sum)

number_1 = int(input("Enter the first number : "))
number_2 = int(input("Enter the second number : "))

sum = number_1 + number_2
print(sum)

"""# Operators in Python


1.   Arithmetic Operators
2.   Assignment Operators
3.   Comparison Operators
4.   Logical Operators
5.   Identity Operators
6.   Membership Operators


"""

#Arithmatic opearators

number_1 = 20
number_2 = 10
print(number_1 + number_2)
print(number_1 - number_2)
print(number_1 * number_2)
print(number_1 / number_2)
print(number_1 % number_2)

# Assignment operator

a = 5  # Simple assignment
a += 3 # Equivalent to a = a + 3
print(a)
a -= 2 # Equivalent to a = a - 2
print(a)
a *= 4 # Equivalent to a = a * 4
print(a)
a /= 8 # Equivalent to a = a / 8
print(a)
a %= 3 # Equivalent to a = a % 3
print(a)
a = 5
a //= 2 # Equivalent to a = a // 2 (floor division)
print(a)
a = 5
a **= 3 # Equivalent to a = a ** 3 (exponentiation)
a

# Comparison Operators

# Equality (==)
print(5 == 5)  # True
print(5 == 10) # False

# Inequality (!=)
print(5 != 10) # True
print(5 != 5)  # False

# Greater than (>)
print(10 > 5) # True
print(5 > 10) # False

# Less than (<)
print(5 < 10) # True
print(10 < 5) # False

# Greater than or equal to (>=)
print(10 >= 10) # True
print(10 >= 5)  # True
print(5 >= 10)  # False

# Less than or equal to (<=)
print(5 <= 5)  # True
print(5 <= 10) # True
print(10 <= 5) # False

# Logical Operators

# AND (and): Returns True if both operands are True.
print(True and True)   # True
print(True and False)  # False
print(False and True)  # False
print(False and False) # False

# OR (or): Returns True if at least one of the operands is True.
print(True or True)   # True
print(True or False)  # True
print(False or True)  # True
print(False or False) # False

# NOT (not): Returns the opposite of the operand.
print(not True)  # False
print(not False) # True

# Examples with expressions
x = 5
y = 10
print(x > 3 and y < 12) # True and True -> True
print(x < 3 and y < 12) # False and True -> False
print(x < 3 or y < 12)  # False or True -> True
print(not (x == 5))     # not True -> False

# Identity Operators
# Identity operators are used to compare the memory locations of two objects.

# is: Returns True if both variables point to the same object in memory.
x = [1, 2, 3]
y = [1, 2, 3]
z = x

print(x is z) # True (x and z point to the same list object)
print(x is y) # False (x and y are different list objects, even if they have the same contents)

# is not: Returns True if both variables do NOT point to the same object in memory.
print(x is not y) # True
print(x is not z) # False

# Important Note: For immutable objects like numbers and strings, Python may sometimes optimize by pointing multiple variables with the same value to the same memory location. This behavior is not guaranteed and should not be relied upon for general object comparison. Use `==` for value comparison and `is` for identity comparison.

a = 10
b = 10
print(a is b) # May print True due to optimization for small integers

s1 = "hello"
s2 = "hello"
print(s1 is s2) # May print True due to string interning

# Membership Operators
# Membership operators are used to test whether a sequence (like strings, lists, tuples, sets, or dictionaries) contains a specified value.

# in: Returns True if a value is found in the sequence.
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)     # True
print(6 in my_list)     # False

my_string = "hello world"
print("world" in my_string) # True
print("z" in my_string)   # False

my_tuple = (10, 20, 30)
print(20 in my_tuple)   # True

my_set = {1, 2, 3, 4}
print(4 in my_set)      # True

my_dict = {'name': 'Alice', 'age': 25}
print('name' in my_dict)  # True (checks for keys)
print('Alice' in my_dict) # False (does not check for values directly)
print('Alice' in my_dict.values()) # True (explicitly checks values)

# not in: Returns True if a value is NOT found in the sequence.
my_list = [1, 2, 3, 4, 5]
print(6 not in my_list)     # True
print(3 not in my_list)     # False

my_string = "hello world"
print("z" not in my_string)   # True
print("world" not in my_string) # False

my_dict = {'name': 'Alice', 'age': 25}
print('city' not in my_dict)  # True
print('name' not in my_dict)  # False

"""# If-Else statement"""

# Basic If statement
x = 10

if x > 5:
  print("x is greater than 5")

# If-Else statement
y = 3

if y > 5:
  print("y is greater than 5")
else:
  print("y is not greater than 5")

# If-Elif-Else statement
score = 85

if score >= 90:
  print("Grade A")
elif score >= 80:
  print("Grade B")
elif score >= 70:
  print("Grade C")
else:
  print("Grade D")

"""# Loops in python"""

# While loop
# Repeats a block of code as long as a condition is true.
count = 0
while count < 5:
  print(f"Count is: {count}")
  count += 1

# For loop
# Iterates over a sequence (like a list, tuple, string, range).
my_list = [1, 2, 3, 4, 5]
for item in my_list:
  print(item)

my_string = "Python"
for char in my_string:
  print(char)

# Using range() with For loop
# range(stop): numbers from 0 up to (but not including) stop
for i in range(5):
  print(i)

# range(start, stop): numbers from start up to (but not including) stop
for i in range(2, 7):
  print(i)

# range(start, stop, step): numbers from start up to (but not including) stop, with a specified step
for i in range(0, 10, 2):
  print(i)

# Iterating over a dictionary
my_dict = {'a': 1, 'b': 2, 'c': 3}

# Iterate over keys
for key in my_dict:
  print(key)

# Iterate over values
for value in my_dict.values():
  print(value)

# Iterate over key-value pairs
for key, value in my_dict.items():
  print(f"Key: {key}, Value: {value}")

# Break statement
# Exits the loop immediately.
for i in range(10):
  if i == 5:
    break
  print(i)

# Continue statement
# Skips the rest of the current iteration and moves to the next.
for i in range(10):
  if i % 2 == 0:
    continue # Skip even numbers
  print(i)

# Nested loops
# A loop inside another loop.
for i in range(3):
  for j in range(2):
    print(f"Outer loop: {i}, Inner loop: {j}")

"""# Function"""

def my_function():
  """This is a docstring explaining what the function does."""
  print("Hello from a function!")

# Calling the function
my_function()

# Function with parameters
def greet(name):
  print(f"Hello, {name}!")

greet("Alice")
greet("Bob")

# Function with default parameter value
def greet_default(name="World"):
  print(f"Hello, {name}!")

greet_default()        # Uses the default value
greet_default("Python") # Overrides the default value

# Function with return value
def add(a, b):
  return a + b

result = add(5, 3)
print(f"The sum is: {result}")

# Function returning multiple values (as a tuple)
def get_min_max(numbers):
  return min(numbers), max(numbers)

numbers = [1, 5, 2, 8, 3]
minimum, maximum = get_min_max(numbers)
print(f"Minimum: {minimum}, Maximum: {maximum}")

# Arbitrary Arguments, *args (for a non-keyworded variable length argument list)
def my_function_args(*kids):
  print("The youngest child is " + kids[2])

my_function_args("Emil", "Tobias", "Linus")

# Keyword Arguments, **kwargs (for a keyworded variable length argument list)
def my_function_kwargs(**kid):
  print("His last name is " + kid["lname"])

my_function_kwargs(fname = "Tobias", lname = "Refsnes")

# Lambda Functions (Anonymous Functions)
# A small anonymous function. A lambda function can take any number of arguments, but can only have one expression.
x = lambda a : a + 10
print(x(5))

# Lambda functions can take multiple arguments
x = lambda a, b : a * b
print(x(5, 6))

# Lambda functions can be used inside other functions
def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(mydoubler(11))
print(mytripler(11))

"""# Read and Write function"""

# Read and write file

# Write to a file
with open('my_file.txt', 'w') as f:
    f.write('Hello, Colab!\n')
    f.write('This is a test file.')

# Read from a file
with open('my_file.txt', 'r') as f:
    content = f.read()
content

"""# Exception handling"""

# Exception handling

try:
  # Code that might raise an exception
  result = 10 / 0
except ZeroDivisionError:
  # Code to handle ZeroDivisionError
  print("Error: Cannot divide by zero!")
except Exception as e:
  # Code to handle any other type of exception
  print(f"An unexpected error occurred: {e}")
else:
  # Code to run if no exception occurs in the try block
  print("Division was successful!")
finally:
  # Code that runs no matter what (whether an exception occurred or not)
  print("This block always executes.")

# Example with a different potential error
try:
  my_list = [1, 2, 3]
  print(my_list[5])
except IndexError:
  print("Error: Index is out of range!")
except Exception as e:
  print(f"An unexpected error occurred: {e}")
else:
  print("Access was successful!")
finally:
  print("This block always executes.")

# Raising a custom exception
def validate_age(age):
  if age < 0:
    raise ValueError("Age cannot be negative")
  print(f"Valid age: {age}")

try:
  validate_age(-5)
except ValueError as e:
  print(f"Caught an error: {e}")

try:
  validate_age(30)
except ValueError as e:
  print(f"Caught an error: {e}")
else:
  print("Age validation successful.")

"""# Class and Objects"""

# class and object

# Define a class
class Dog:
  # The __init__ method is the constructor for a class.
  # It's called when you create a new object from the class.
  # 'self' refers to the instance of the class itself.
  def __init__(self, name, age):
    self.name = name  # Attribute: The dog's name
    self.age = age    # Attribute: The dog's age

  # Method: A function defined inside a class
  def bark(self):
    print(f"{self.name} says Woof!")

  def get_info(self):
    return f"{self.name} is {self.age} years old."

# Create objects (instances) of the Dog class
# This calls the __init__ method
dog1 = Dog("Buddy", 5)
dog2 = Dog("Lucy", 3)

# Access attributes of the objects
print(f"Dog 1's name: {dog1.name}")
print(f"Dog 2's age: {dog2.age}")

# Call methods on the objects
dog1.bark()
dog2.bark()

print(dog1.get_info())
print(dog2.get_info())

"""# Main function"""

# Main function in python

if __name__ == "__main__":
    # Your main execution logic goes here
    # This block will only run when the script is executed directly
    print("This is the main execution block.")

    # Example usage of a function defined earlier
    my_function()

    # Example of calling a function with arguments
    greet("World")

    # Example of calling a function with return value
    sum_result = add(10, 20)
    print(f"Sum from main: {sum_result}")

    # Example of using a class
    my_dog = Dog("Rex", 7)
    my_dog.bark()
    print(my_dog.get_info())

    # Example of using exception handling
    try:
        validate_age(45)
    except ValueError as e:
        print(f"Caught error in main: {e}")